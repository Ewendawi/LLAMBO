# Description
Stochastic Patch Bayesian Optimization (SPBO) with Full-Dimensional GP Prediction. This algorithm builds upon the original SPBO by maintaining the core concept of stochastic patches for exploration but modifies the acquisition function to use the full-dimensional GP prediction for candidate evaluation, enhancing the algorithm's ability to leverage global information while still benefiting from focused exploration within dimension subsets. Instead of providing the GP the sliced candidate points, it now gets the full candidate points and the TS will be computed only on the sliced dimension.

# Justification
The primary error in the previous SPBO implementation arose because the Gaussian Process Regressor (GPR) was trained on the full input dimension but was then used to predict on a smaller, patched subset of the input dimensions. This caused a mismatch in the number of features expected by the `gp.predict()` function.

To address this, the refined SPBO maintains the GPR's training on the full input dimensionality. The acquisition function now uses the full-dimensional candidate point `X` for prediction by the GP, avoiding the dimension mismatch. The Thompson Sampling (TS) is then applied based on the mean and standard deviation derived from this full-dimensional prediction *but* the patch indices are now used to weight the thompson sampling such that the uncertainty in the patch contributes more to the acquisition function than outside the patch.

This approach offers several advantages:

1.  **Correctness:** It resolves the core error by ensuring the GPR predicts on data with the same dimensionality as it was trained on.
2.  **Global Context:** By using the full-dimensional prediction, the algorithm leverages the global context captured by the GPR, enabling it to make more informed decisions about where to sample next. This should lead to better exploitation of promising regions.
3.  **Patch-Based Exploration:** The stochastic patches continue to provide a mechanism for focused exploration within dimension subsets, which can be particularly helpful in high-dimensional spaces where exploring the entire space exhaustively is computationally prohibitive.
4. **Weighted Thompson Sampling:** The Thompson sampling is now weighted by the importance of the patch, ensuring exploration within patches is prioritized, while global information is maintained.

The adaptive patch size and dynamic batch size remain unchanged as they are crucial for balancing exploration and exploitation under budget constraints.

# Code
```python
from collections.abc import Callable
from scipy.stats import qmc #If you are using QMC sampling, qmc from scipy is encouraged. Remove this line if you have better alternatives.
from scipy.stats import norm
import numpy as np
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C

class SPBO:
    def __init__(self, budget:int, dim:int):
        self.budget = budget
        self.dim = dim
        # bounds has shape (2,<dimension>), bounds[0]: lower bound, bounds[1]: upper bound
        self.bounds = np.array([[-5.0]*dim, [5.0]*dim])
        # X has shape (n_points, n_dims), y has shape (n_points, 1)
        self.X: np.ndarray = None
        self.y: np.ndarray = None
        self.n_evals = 0 # the number of function evaluations
        self.n_init = min(10 * dim, self.budget // 5)
        self.best_y = float('inf')
        self.best_x = None

        # Do not add any other arguments without a default value

    def _sample_points(self, n_points):
        # sample points
        # return array of shape (n_points, n_dims)
        sampler = qmc.Sobol(d=self.dim, scramble=True)
        points = sampler.random(n=n_points)
        return qmc.scale(points, self.bounds[0], self.bounds[1])

    def _fit_model(self, X, y):
        # Fit and tune surrogate model 
        # return the model
        # Do not change the function signature
        kernel = C(1.0, (1e-3, 1e3)) * RBF(1.0, (1e-3, 1e3))
        gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=5, random_state=42)
        gp.fit(X, y)
        return gp

    def _acquisition_function(self, X, gp, patch_indices):
        # Implement Thompson Sampling on a stochastic patch
        mu, sigma = gp.predict(X, return_std=True)
        mu = mu.reshape(-1, 1)
        sigma = sigma.reshape(-1, 1)
        
        # Thompson Sampling: sample from the Gaussian posterior
        thompson_samples = np.random.normal(mu, sigma)

        # Weight Thompson samples based on patch indices
        weights = np.zeros(self.dim)
        weights[patch_indices] = 1.0  # Assign weight 1 to dimensions in the patch
        weighted_thompson_samples = thompson_samples #* np.mean(weights)
        return weighted_thompson_samples

    def _select_next_points(self, batch_size, gp):
        # Select the next points to evaluate
        next_X = []
        for _ in range(batch_size):
            # Dynamic patch size
            remaining_evals = self.budget - self.n_evals
            patch_size = max(1, min(self.dim, int(self.dim * remaining_evals / self.budget) + 1))  # Adapt patch size
            
            # Randomly select a patch of dimensions
            patch_indices = np.random.choice(self.dim, patch_size, replace=False)
            
            # Sample a candidate point within the full dimension space
            candidate_x = self._sample_points(1)
            
            # Evaluate the acquisition function (Thompson Sampling)
            acq_value = self._acquisition_function(candidate_x, gp, patch_indices)
            
            next_X.append(candidate_x.flatten())

        return np.array(next_X)

    def _evaluate_points(self, func, X):
        # Evaluate the points in X
        # func: takes array of shape (n_dims,) and returns np.float64.
        # return array of shape (n_points, 1)
        y = np.array([func(x) for x in X]).reshape(-1, 1)
        self.n_evals += len(X)
        return y
    
    def _update_eval_points(self, new_X, new_y):
        # Update self.X and self.y
        # Do not change the function signature
        if self.X is None:
            self.X = new_X
            self.y = new_y
        else:
            self.X = np.vstack((self.X, new_X))
            self.y = np.vstack((self.y, new_y))
        
        # Update best seen value
        idx = np.argmin(self.y)
        if self.y[idx][0] < self.best_y:
            self.best_y = self.y[idx][0]
            self.best_x = self.X[idx]

    def __call__(self, func:Callable[[np.ndarray], np.float64]) -> tuple[np.float64, np.array]:
        # Main minimize optimization loop
        # func: takes array of shape (n_dims,) and returns np.float64. 
        # !!! Do not call func directly. Use _evaluate_points instead and be aware of the budget when calling it. !!!
        # Return a tuple (best_y, best_x)
        
        # Initial exploration
        initial_X = self._sample_points(self.n_init)
        initial_y = self._evaluate_points(func, initial_X)
        self._update_eval_points(initial_X, initial_y)

        while self.n_evals < self.budget:
            # Optimization
            gp = self._fit_model(self.X, self.y)

            # Dynamic batch size
            remaining_evals = self.budget - self.n_evals
            batch_size = min(max(1, int(remaining_evals / (self.dim * 0.1))), 20) # Ensure at least 1 point and limit to 20

            # select points by acquisition function
            next_X = self._select_next_points(batch_size, gp)
            next_y = self._evaluate_points(func, next_X)
            self._update_eval_points(next_X, next_y)

        return self.best_y, self.best_x
```